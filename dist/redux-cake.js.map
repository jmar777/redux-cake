{"version":3,"file":"redux-cake.js","sources":["../src/index.js"],"sourcesContent":["import { combineReducers as reduxCombineReducers } from 'redux';\n\nconst REDUX_CAKE_SLICE = '@@redux-cake';\nconst REDUX_INIT = '@@redux/INIT';\n\nlet store, previousReducers;\n\n// keeps track of a slice to remove after replacing the reducer\n// (we only have a small window to remove it from state before\n// combineReducers complains about it)\nlet sliceToRemove = null;\n\n/**\n * Action types that will be dispatched during the lifecycle of dynamically\n * added or removed slices. Possible options are `ActionTypes.SLICE_ADDED`\n * and `ActionTypes.SLICE_REMOVED`.\n */\nexport const ActionTypes = {\n  SLICE_ADDED: '@@redux-cake/SLICE_ADDED',\n  SLICE_REMOVED: '@@redux-cake/SLICE_REMOVED'\n};\n\n/**\n * The store enhancer used to enable dynamic slice management. We mostly just\n * need this to grab a few references that we'll need later on.\n */\nexport const reduxCake = createStore => (reducer, preloadedState, enhancer) => {\n  if (!reducer.originalReducers) {\n    throw new Error('Redux Cake only works if you use our `combineReducers` function!');\n  }\n\n  // grab our reference to the store\n  store = createStore(reducer, preloadedState, enhancer);\n\n  previousReducers = reducer.originalReducers;\n\n  return store;\n};\n\n/**\n * Adds a new slice of state to the reducer.\n * @param {string} key The slice of state that the new reducer should manage.\n * @param {function} reducer The reducer for this slice of state.\n */\nexport const addSlice = (key, reducer) => {\n  if (!store) {\n    throw new Error('Cannot call addSlice() without first using the `reduxCake` enhancer.');\n  }\n\n  if (previousReducers[key]) {\n    console.warn(`There is already a slice with key \"${key}\". This slice was ignored.`);\n    return;\n  }\n\n  previousReducers = {\n    ...previousReducers,\n    [key]: reducer\n  };\n\n  store.replaceReducer(combineReducers(previousReducers));\n\n  store.dispatch({ type: ActionTypes.SLICE_ADDED, payload: key });\n};\n\n/**\n * Removes a slice of state from the reducer.\n * @param {string} key The slice of state that should be removed.\n */\nexport const removeSlice = key => {\n  if (!store) {\n    throw new Error('Cannot call removeSlice() without first using the `reduxCake` enhancer.');\n  }\n\n  if (!previousReducers[key]) {\n    return;\n  }\n\n  previousReducers = { ...previousReducers };\n  delete previousReducers[key];\n\n  sliceToRemove = key;\n\n  store.replaceReducer(combineReducers(previousReducers));\n\n  sliceToRemove = null;\n\n  store.dispatch({ type: ActionTypes.SLICE_REMOVED, payload: key });\n};\n\n/**\n * A wrapper around Redux's `combineReducers` implementation, giving us a\n * chance to intercept key actions, as well as grab a reference to the\n * raw reducers object.\n * @param {object} reducers An object whose keys represent slices of state,\n *   and whose corresponding values represent reducing functions for their\n *   respective slices of state.\n * @returns {function} A reducer that will invoke the sub reducers for each\n *   slice of state, returning the complete, combined state object.\n */\nexport const combineReducers = reducers => {\n  // no need to make reducers required in this version\n  if (!reducers) reducers = {};\n\n  // we insert a dummy slice to keep the default `combineReducers` implementation\n  // from warning about empty reducer objects\n  if (!reducers[REDUX_CAKE_SLICE]) {\n    reducers[REDUX_CAKE_SLICE] = state => null;\n  }\n\n  const combined = reduxCombineReducers(reducers);\n\n  const finalReducer = (state, action) => {\n    if (action && action.type === REDUX_INIT && sliceToRemove) {\n      state = { ...state };\n      delete state[sliceToRemove];\n    }\n\n    return combined(state, action);\n  };\n\n  finalReducer.originalReducers = reducers;\n\n  return finalReducer;\n};\n"],"names":["store","previousReducers","sliceToRemove","ActionTypes","combineReducers","reducers","combined","reduxCombineReducers","finalReducer","state","action","type","originalReducers","reducer","preloadedState","enhancer","Error","createStore","key","warn","replaceReducer","dispatch","SLICE_ADDED","payload","SLICE_REMOVED"],"mappings":"mgBAKIA,SAAOC,SAKPC,EAAgB,KAOPC,eACE,yCACE,8BAgFJC,EAAkB,YAExBC,IAAUA,MAIVA,EAvGkB,oBAAA,gBAwGQ,mBAAS,WAGlCC,EAAWC,kBAAqBF,GAEhCG,EAAe,SAACC,EAAOC,UACvBA,GA7GW,iBA6GDA,EAAOC,MAAuBT,iBAC7BO,IACAP,GAGRI,EAASG,EAAOC,aAGZE,iBAAmBP,EAEzBG,+BAhGgB,mBAAe,SAACK,EAASC,EAAgBC,OAC3DF,EAAQD,uBACL,IAAII,MAAM,6EAIVC,EAAYJ,EAASC,EAAgBC,KAE1BF,EAAQD,iBAEpBZ,eAQe,SAACkB,EAAKL,OACvBb,QACG,IAAIgB,MAAM,wEAGdf,EAAiBiB,WACXC,2CAA2CD,wCAKhDjB,OACFiB,EAAML,MAGHO,eAAehB,EAAgBH,MAE/BoB,UAAWV,KAAMR,EAAYmB,YAAaC,QAASL,oBAOhC,gBACpBlB,QACG,IAAIgB,MAAM,2EAGbf,EAAiBiB,mBAIEjB,IACAiB,KAERA,IAEVE,eAAehB,EAAgBH,MAErB,OAEVoB,UAAWV,KAAMR,EAAYqB,cAAeD,QAASL"}