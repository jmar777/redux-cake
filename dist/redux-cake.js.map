{"version":3,"file":"redux-cake.js","sources":["../src/index.js"],"sourcesContent":["import { combineReducers as reduxCombineReducers } from 'redux';\nconsole.log('updated redux cake', 1);\nconst REDUX_CAKE_SLICE = '@@redux-cake';\nconst REDUX_INIT = '@@redux/INIT';\n\nlet store, previousReducers;\n\n/**\n * Slice operations (`addSlice()` and `removeSlice()`) can come in before the\n * store has been created, so we queue them up briefly, to allow initialization\n * to complete.\n */\nconst pendingSliceOps = [];\nlet initializationTimer;\n\n/**\n * Keeps track of a slice to remove after replacing the reducer\n * (we only have a small window to remove it from state before\n * combineReducers complains about it)\n */\nlet sliceToRemove = null;\n\n/**\n * Action types that will be dispatched during the lifecycle of dynamically\n * added or removed slices. Possible options are `ActionTypes.SLICE_ADDED`\n * and `ActionTypes.SLICE_REMOVED`.\n */\nexport const ActionTypes = {\n  SLICE_ADDED: '@@redux-cake/SLICE_ADDED',\n  SLICE_REMOVED: '@@redux-cake/SLICE_REMOVED'\n};\n\n/**\n * The store enhancer used to enable dynamic slice management. We mostly just\n * need this to grab a few references that we'll need later on.\n */\nexport const reduxCake = createStore => (reducer, preloadedState, enhancer) => {\n  if (!reducer.originalReducers) {\n    throw new Error('Redux Cake only works if you use our `combineReducers` function!');\n  }\n\n  // grab our reference to the store\n  store = createStore(reducer, preloadedState, enhancer);\n\n  previousReducers = reducer.originalReducers;\n\n  let isStoreInitialized = true;\n  clearTimeout(initializationTimer);\n\n  // loop through any pending addSlice() or removeSlice() operations\n  pendingSliceOps.forEach(op => op());\n  pendingSliceOps.length = 0;\n\n  return store;\n};\n\n/**\n * Adds a new slice of state to the reducer.\n * @param {string} key The slice of state that the new reducer should manage.\n * @param {function} reducer The reducer for this slice of state.\n */\nexport const addSlice = (key, reducer) => {\n  if (!store) {\n    startInitializationTimer();\n    pendingSliceOps.push(() => addSlice(key, reducer));\n    return;\n  }\n\n  if (previousReducers[key]) {\n    console.warn(`There is already a slice with key \"${key}\". This slice was ignored.`);\n    return;\n  }\n\n  previousReducers = {\n    ...previousReducers,\n    [key]: reducer\n  };\n\n  store.replaceReducer(combineReducers(previousReducers));\n\n  store.dispatch({ type: ActionTypes.SLICE_ADDED, payload: key });\n};\n\n/**\n * Removes a slice of state from the reducer.\n * @param {string} key The slice of state that should be removed.\n */\nexport const removeSlice = key => {\n  if (!store) {\n    startInitializationTimer();\n    pendingSliceOps.push(() => removeSlice(key));\n    return;\n  }\n\n  if (!previousReducers[key]) {\n    return;\n  }\n\n  previousReducers = { ...previousReducers };\n  delete previousReducers[key];\n\n  sliceToRemove = key;\n\n  store.replaceReducer(combineReducers(previousReducers));\n\n  sliceToRemove = null;\n\n  store.dispatch({ type: ActionTypes.SLICE_REMOVED, payload: key });\n};\n\n/**\n * A wrapper around Redux's `combineReducers` implementation, giving us a\n * chance to intercept key actions, as well as grab a reference to the\n * raw reducers object.\n * @param {object} reducers An object whose keys represent slices of state,\n *   and whose corresponding values represent reducing functions for their\n *   respective slices of state.\n * @returns {function} A reducer that will invoke the sub reducers for each\n *   slice of state, returning the complete, combined state object.\n */\nexport const combineReducers = reducers => {\n  // no need to make reducers required in this version\n  if (!reducers) reducers = {};\n\n  // we insert a dummy slice to keep the default `combineReducers` implementation\n  // from warning about empty reducer objects\n  if (!reducers[REDUX_CAKE_SLICE]) {\n    reducers[REDUX_CAKE_SLICE] = state => null;\n  }\n\n  const combined = reduxCombineReducers(reducers);\n\n  const finalReducer = (state, action) => {\n    if (action && action.type === REDUX_INIT && sliceToRemove) {\n      state = { ...state };\n      delete state[sliceToRemove];\n    }\n\n    return combined(state, action);\n  };\n\n  finalReducer.originalReducers = reducers;\n\n  return finalReducer;\n};\n\nconst startInitializationTimer = () => {\n  if (initializationTimer) return;\n\n  initializationTimer = setTimeout(() => {\n    console.warn('It looks like you forgot to use the reduxCake store enhancer!');\n  }, 1000);\n};\n"],"names":["console","log","store","previousReducers","pendingSliceOps","initializationTimer","sliceToRemove","ActionTypes","combineReducers","reducers","combined","reduxCombineReducers","finalReducer","state","action","type","originalReducers","startInitializationTimer","setTimeout","warn","reducer","preloadedState","enhancer","Error","createStore","forEach","op","length","addSlice","key","push","replaceReducer","dispatch","SLICE_ADDED","payload","removeSlice","SLICE_REMOVED"],"mappings":"mgBAAAA,QACQC,IAAI,qBAAsB,GAClC,IAGIC,SAAOC,SAOLC,KACFC,SAOAC,EAAgB,KAOPC,eACE,yCACE,8BA2FJC,EAAkB,YAExBC,IAAUA,MAIVA,EA5HkB,oBAAA,gBA6HQ,mBAAS,WAGlCC,EAAWC,kBAAqBF,GAEhCG,EAAe,SAACC,EAAOC,UACvBA,GAlIW,iBAkIDA,EAAOC,MAAuBT,iBAC7BO,IACAP,GAGRI,EAASG,EAAOC,aAGZE,iBAAmBP,EAEzBG,GAGHK,EAA2B,WAC3BZ,MAEkBa,WAAW,mBACvBC,KAAK,kEACZ,mCAnHoB,mBAAe,SAACC,EAASC,EAAgBC,OAC3DF,EAAQJ,uBACL,IAAIO,MAAM,6EAIVC,EAAYJ,EAASC,EAAgBC,KAE1BF,EAAQJ,8BAGdX,KAGGoB,QAAQ,mBAAMC,QACdC,OAAS,EAElBzB,eAQe,SAAX0B,EAAYC,EAAKT,OACvBlB,oBAEa4B,KAAK,kBAAMF,EAASC,EAAKT,KAIvCjB,EAAiB0B,WACXV,2CAA2CU,wCAKhD1B,OACF0B,EAAMT,MAGHW,eAAevB,EAAgBL,MAE/B6B,UAAWjB,KAAMR,EAAY0B,YAAaC,QAASL,oBAOhC,SAAdM,SACNjC,oBAEa4B,KAAK,kBAAMK,EAAYN,KAIpC1B,EAAiB0B,mBAIE1B,IACA0B,KAERA,IAEVE,eAAevB,EAAgBL,MAErB,OAEV6B,UAAWjB,KAAMR,EAAY6B,cAAeF,QAASL"}